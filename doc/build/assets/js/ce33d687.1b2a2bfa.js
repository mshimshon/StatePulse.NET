"use strict";(self.webpackChunkstatepulse_doc=self.webpackChunkstatepulse_doc||[]).push([[6996],{4978:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"The Dispatcher","title":"The Dispatcher","description":"\ud83d\ude80 Dispatcher \u2013 Executing Actions in StatePulse","source":"@site/docs/6.The Dispatcher.md","sourceDirName":".","slug":"/gs-the-dispatcher","permalink":"/gs-the-dispatcher","draft":false,"unlisted":false,"editUrl":"https://github.com/mshimshon/StatePulse.NET/docs/6.The Dispatcher.md","tags":[{"inline":true,"label":"blazor","permalink":"/tags/blazor"},{"inline":true,"label":"state-management","permalink":"/tags/state-management"},{"inline":true,"label":"dispatcher","permalink":"/tags/dispatcher"},{"inline":true,"label":"actions","permalink":"/tags/actions"},{"inline":true,"label":"safedispatch","permalink":"/tags/safedispatch"},{"inline":true,"label":"redux","permalink":"/tags/redux"},{"inline":true,"label":"statepulse","permalink":"/tags/statepulse"},{"inline":true,"label":"async","permalink":"/tags/async"},{"inline":true,"label":"await","permalink":"/tags/await"},{"inline":true,"label":"performance","permalink":"/tags/performance"}],"version":"current","sidebarPosition":6,"frontMatter":{"slug":"gs-the-dispatcher","title":"The Dispatcher","tags":["blazor","state-management","dispatcher","actions","safedispatch","redux","statepulse","async","await","performance"],"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"The Reducers","permalink":"/gs-the-reducer"},"next":{"title":"The Middlewares","permalink":"/gs-the-middlewares"}}');var i=t(4848),r=t(8453);const a={slug:"gs-the-dispatcher",title:"The Dispatcher",tags:["blazor","state-management","dispatcher","actions","safedispatch","redux","statepulse","async","await","performance"],sidebar_position:6},c=void 0,l={},o=[{value:"\ud83d\ude80 Dispatcher \u2013 Executing Actions in StatePulse",id:"-dispatcher--executing-actions-in-statepulse",level:2},{value:"\ud83e\udded Dispatch Flow",id:"-dispatch-flow",level:3},{value:"\u26a0\ufe0f About Constructors",id:"\ufe0f-about-constructors",level:3},{value:"Inject into Component",id:"inject-into-component",level:3},{value:"\ud83d\udee0\ufe0f Pre-initializing Actions (Optional)",id:"\ufe0f-pre-initializing-actions-optional",level:3},{value:"\ud83e\uddf5 Safe Execution On-the-Fly",id:"-safe-execution-on-the-fly",level:3},{value:"\u26a0\ufe0f Use Safe Actions Selectively",id:"\ufe0f-use-safe-actions-selectively",level:3},{value:"\u23f3 Await Pipeline",id:"-await-pipeline",level:3},{value:"Why Awaiting Matters in .NET / StatePulse",id:"why-awaiting-matters-in-net--statepulse",level:4}];function h(e){const n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"-dispatcher--executing-actions-in-statepulse",children:"\ud83d\ude80 Dispatcher \u2013 Executing Actions in StatePulse"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"dispatcher"})," in StatePulse is responsible for preparing and executing actions in a clean and fluent way.",(0,i.jsx)(n.br,{}),"\n","Unlike some traditional systems, the dispatch pattern here is more structured:"]}),"\n",(0,i.jsx)(n.h3,{id:"-dispatch-flow",children:"\ud83e\udded Dispatch Flow"}),"\n",(0,i.jsx)(n.p,{children:"The standard flow for dispatching an action is:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Prepare<TAction>()"})," \u2013 creates the action instance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".With(...)"})," \u2013 sets properties on the action"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".DispatchAsync()"})," \u2013 executes the action"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach promotes immutability, clear intent, and safe updates."}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-about-constructors",children:"\u26a0\ufe0f About Constructors"}),"\n",(0,i.jsxs)(n.p,{children:["You ",(0,i.jsx)(n.strong,{children:"can"})," pass constructor arguments in ",(0,i.jsx)(n.code,{children:"Prepare<T>()"}),", like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"Dispatcher.Prepare<MyAction>(arg1, arg2);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But this is ",(0,i.jsx)(n.strong,{children:"strongly discouraged"}),", and ideally avoided completely."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2757 ",(0,i.jsx)(n.strong,{children:"Why avoid it?"}),(0,i.jsx)(n.br,{}),"\n","If the constructor changes later (e.g., parameter added, removed, or reordered),",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"the compiler won\u2019t warn you"}),", and your dispatch logic may ",(0,i.jsx)(n.strong,{children:"break silently at runtime"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This can lead to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Incorrect action initialization"}),"\n",(0,i.jsx)(n.li,{children:"Subtle bugs"}),"\n",(0,i.jsx)(n.li,{children:"Hard-to-trace state issues"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"inject-into-component",children:"Inject into Component"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",metastring:'title="Counter.razor.cs"',children:"public partial class Counter : ComponentBase\r\n{\r\n    [Inject] private IDispatcher Dispatcher { get; set; }\r\n    private async Task Increment()\r\n    {\r\n        await Dispatcher.Prepare<IncrementCounterAction>()\r\n             .With(p => p.Delay, 1)\r\n             .DispatchAsync();\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-pre-initializing-actions-optional",children:"\ud83d\udee0\ufe0f Pre-initializing Actions (Optional)"}),"\n",(0,i.jsxs)(n.p,{children:["You can also ",(0,i.jsx)(n.strong,{children:"pre-initialize an action"})," manually \u2014 similar to how it's done in conventional state management systems."]}),"\n",(0,i.jsx)(n.p,{children:"This approach is useful when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["You're using ",(0,i.jsx)(n.strong,{children:"constructor-based action records"})]}),"\n",(0,i.jsxs)(n.li,{children:["You're ",(0,i.jsx)(n.strong,{children:"dispatching actions in a loop"}),", where minimizing per-dispatch overhead matters"]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,i.jsxs)(n.strong,{children:["While the reflection overhead of ",(0,i.jsx)(n.code,{children:"Prepare<T>()"})," is small, it does exist."]})," In performance-critical scenarios (like loops or tight UI updates), ",(0,i.jsx)(n.strong,{children:"pre-initializing the action"})," can offer a slight efficiency gain."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",metastring:'title="Counter.razor.cs"',children:"public partial class Counter : ComponentBase\r\n{\r\n    [Inject] private IDispatcher Dispatcher { get; set; }\r\n    private async Task Increment()\r\n    {\r\n        await Dispatcher.Prepare(()=> new IncrementCounterAction(){\r\n            Delay = 1\r\n        }).DispatchAsync();\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"-safe-execution-on-the-fly",children:"\ud83e\uddf5 Safe Execution On-the-Fly"}),"\n",(0,i.jsxs)(n.p,{children:["Every action in StatePulse can be executed ",(0,i.jsx)(n.strong,{children:"on-the-fly as a safe action"}),",",(0,i.jsx)(n.br,{}),"\n","meaning any ",(0,i.jsx)(n.strong,{children:"subsequent execution cancels the previous one"}),".",(0,i.jsx)(n.br,{}),"\n","This significantly reduces the risk of race conditions in async workflows."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"\u2705 This is especially helpful for API calls, debounced interactions, or long-running processes."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-use-safe-actions-selectively",children:"\u26a0\ufe0f Use Safe Actions Selectively"}),"\n",(0,i.jsxs)(n.p,{children:["While powerful, ",(0,i.jsx)(n.strong,{children:"safe actions come with a small overhead footprint"}),".",(0,i.jsx)(n.br,{}),"\n","You should ",(0,i.jsx)(n.strong,{children:"avoid using them"})," for:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reducer-only actions (e.g., local counter updates)"}),"\n",(0,i.jsx)(n.li,{children:"Instantaneous operations where no async delay exists"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,i.jsxs)(n.strong,{children:["Overusing ",(0,i.jsx)(n.code,{children:"ISafeAction"})," can lead to performance degradation in large or complex UIs."]}),(0,i.jsx)(n.br,{}),"\n","While it's unlikely you'll encounter direct issues in most apps,",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"why not save performance when it's that easy to do?"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"ISafeAction"})," only when the benefits \u2014 like cancellation, deduplication, or race condition protection \u2014 are necessary."]}),"\n",(0,i.jsx)(n.h3,{id:"-await-pipeline",children:"\u23f3 Await Pipeline"}),"\n",(0,i.jsxs)(n.p,{children:["You can ",(0,i.jsx)(n.strong,{children:"await the dispatch pipeline"}),", which means your code will ",(0,i.jsx)(n.strong,{children:"block execution until the entire pipeline completes"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["All ",(0,i.jsx)(n.strong,{children:"effects"})," (including cascading effects) finish"]}),"\n",(0,i.jsxs)(n.li,{children:["All ",(0,i.jsx)(n.strong,{children:"reducers"})," have executed"]}),"\n",(0,i.jsx)(n.li,{children:"The full state update cycle is done"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This feature is ",(0,i.jsx)(n.strong,{children:"not common in traditional Redux-style state management"}),",",(0,i.jsx)(n.br,{}),"\n","which often relies on external tools (like Redux DevTools) to observe state changes asynchronously."]}),"\n",(0,i.jsx)(n.h4,{id:"why-awaiting-matters-in-net--statepulse",children:"Why Awaiting Matters in .NET / StatePulse"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The .NET environment encourages ",(0,i.jsx)(n.strong,{children:"step-by-step debugging"}),", which is often the most effective way to diagnose issues."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".Await()"})," enables this by making the dispatch synchronous from the caller\u2019s perspective."]}),"\n",(0,i.jsxs)(n.li,{children:["This is why it\u2019s ",(0,i.jsx)(n.strong,{children:"important to always await dispatches"})," \u2014 it ensures predictable, debuggable code flow."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",metastring:'title="Counter.razor.cs"',children:"public partial class Counter : ComponentBase\r\n{\r\n    [Inject] private IDispatcher Dispatcher { get; set; }\r\n    private async Task Increment()\r\n    {\r\n        await Dispatcher.Prepare<IncrementCounterAction>()\r\n             .With(p => p.Delay, 1)\r\n             .Await() // <- Block Execution until all tasks are done.\r\n             .DispatchAsync();\r\n    }\r\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);