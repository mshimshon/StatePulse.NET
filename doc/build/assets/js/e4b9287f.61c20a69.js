"use strict";(self.webpackChunkstatepulse_doc=self.webpackChunkstatepulse_doc||[]).push([[7778],{4661:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Getting Started","title":"Get Started","description":"License: MIT","source":"@site/docs/Getting Started.md","sourceDirName":".","slug":"/","permalink":"/","draft":false,"unlisted":false,"editUrl":"https://github.com/mshimshon/StatePulse.NET/docs/Getting Started.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"slug":"/","title":"Get Started","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Updates","permalink":"/versions"},"next":{"title":"Setup Blazor Project","permalink":"/setup-blazor-project"}}');var r=n(4848),s=n(8453);const a={slug:"/",title:"Get Started",sidebar_position:1},l="StatePulse.NET",o={},c=[{value:"Official Documentation",id:"official-documentation",level:3},{value:"What is StatePulse.NET?",id:"what-is-statepulsenet",level:2},{value:"Features",id:"features",level:2},{value:"\ud83d\ude80 <strong>State Management with Zero Boilerplate and Zero Compromises</strong>",id:"-state-management-with-zero-boilerplate-and-zero-compromises",level:3},{value:"Benchmark",id:"benchmark",level:2},{value:"\ud83d\udce6 Installation &amp; Setup",id:"-installation--setup",level:2},{value:"3 Ways to Register Services",id:"3-ways-to-register-services",level:3},{value:"\ud83e\udded How It Works",id:"-how-it-works",level:2},{value:"<strong>Define Actions</strong>:",id:"define-actions",level:3},{value:"<strong>Define Effect</strong>:",id:"define-effect",level:3},{value:"<strong>Define StateFeature</strong>:",id:"define-statefeature",level:3},{value:"<strong>Trigger Dispatch</strong>:",id:"trigger-dispatch",level:3},{value:"Important Notes",id:"important-notes",level:3},{value:"<strong>Access State</strong>:",id:"access-state",level:3},{value:"Blazor Example Usage",id:"blazor-example-usage",level:3}];function d(e){const t={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://opensource.org/licenses/MIT",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/badge/License-MIT-brightgreen.svg",alt:"License: MIT"})}),"\r\n",(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/StatePulse.NET",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/nuget/v/StatePulse.Net",alt:"NuGet Version"})}),"\r\n",(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/StatePulse.NET",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/StatePulse.NET?label=Downloads",alt:""})}),"\r\n",(0,r.jsx)(t.a,{href:"https://github.com/mshimshon/StatePulse.NET/actions/workflows/ci.yml",children:(0,r.jsx)(t.img,{src:"https://github.com/mshimshon/StatePulse.NET/actions/workflows/ci.yml/badge.svg",alt:"Build"})}),"\r\n",(0,r.jsx)(t.a,{href:"https://github.com/mshimshon/StatePulse.NET/actions/workflows/deploy.yml",children:(0,r.jsx)(t.img,{src:"https://github.com/mshimshon/StatePulse.NET/actions/workflows/deploy.yml/badge.svg",alt:"Deploy"})})]}),"\n",(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"statepulsenet",children:"StatePulse.NET"})}),"\n",(0,r.jsx)(t.h3,{id:"official-documentation",children:(0,r.jsx)(t.a,{href:"https://statepulse.net/",children:"Official Documentation"})}),"\n",(0,r.jsx)(t.h2,{id:"what-is-statepulsenet",children:"What is StatePulse.NET?"}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/6XKSyUe9yOM?si=nnclq5_ap3szxqrT",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0}),"\n",(0,r.jsx)(t.p,{children:"StatePulse.NET is a precision\u2011engineered state and action management system designed for high\u2011performance fire\u2011and\u2011yield workflows. It supports optional, internally controlled execution ordering when deterministic sequencing is explicitly required.\r\nIts multi\u2011layer anti\u2011duplication pipeline eliminates redundant dispatches, prevents race conditions, and maintains consistent outcomes even under rapid input or concurrent triggers.\r\nA lightweight internal tracking core provides near\u2011zero\u2011overhead cancellation and dispatch control, minimizing inconsistency without sacrificing throughput.\r\nDespite these guarantees, StatePulse.NET preserves the flexibility of traditional untracked state management, allowing developers to selectively enforce ordering and reliability without introducing global locks or compromising responsiveness."}),"\n",(0,r.jsx)(t.h1,{id:"getting-started",children:"Getting Started"}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/YkntxdIyZIU?si=pB1MDG549lB4F2T2",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0}),"\n",(0,r.jsx)(t.h2,{id:"features",children:"Features"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Fast Fire-and-Yield"}),(0,r.jsx)(t.br,{}),"\n","Executes actions immediately, including tracked actions, while preserving fire-and-yield semantics."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Multi-Layer Anti-Duplicate Dispatching"}),"\r\nLayer 1: Cancels previously dispatched duplicates before effects, between effects, or after effects, ensuring no redundant action progresses through the pipeline.\r\nLayer 2: Uses a global state-change ticker enforcing a strict \u201clatest action wins\u201d rule so outdated or superseded actions cannot update state."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Effect Validator System"}),(0,r.jsx)(t.br,{}),"\n","Supports multiple, composable validators for modular and reusable rule enforcement."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Synchronous Debug Mode"}),(0,r.jsx)(t.br,{}),"\n","Provides an optional lockstep execution mode ideal for testing, diagnostics, and ",(0,r.jsx)(t.code,{children:"Task.WhenAll"})," based pipelines."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"DispatchTracker"}),(0,r.jsx)(t.br,{}),"\n","Offers high-performance cancellation, deduplication, and concurrency control through an optimized tracking mechanism."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Short-Lived Middlewares"}),"\r\nProvides lightweight, disposable middleware hooks that run only during the lifetime of a single dispatch cycle."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Dispatch Middlewares"}),"\r\nRuns Before, After, and WhenDispatchFails. In asynchronous dispatch modes, failures are silently discarded unless handled internally, so DEC logic should manage its own errors; a logging middleware can also capture unhandled pipeline failures."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Effect Middlewares"}),"\r\nRuns Before, After, WhenValidationFails, and WhenValidationSucceed, allowing fine\u2011grained control and instrumentation around effect execution and validation flow."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Reducer Middlewares"}),"\r\nRuns Before and After the reducer, enabling patterns such as event dispatch on state changes, logging, instrumentation, or enforcing reducer\u2011level invariants."]}),"\n",(0,r.jsxs)(t.h3,{id:"-state-management-with-zero-boilerplate-and-zero-compromises",children:["\ud83d\ude80 ",(0,r.jsx)(t.strong,{children:"State Management with Zero Boilerplate and Zero Compromises"})]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Lazy State Access Model:"})," Inject ",(0,r.jsx)(t.code,{children:"IStatePulse"})," directly into your Blazor component and call ",(0,r.jsx)(t.code,{children:"StateOf<TState>(()=>this, TaskMethod)"})," to get scoped state access."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Component-Scoped Event Listening:"})," Automatically registers event listeners only for that component, ensuring ",(0,r.jsx)(t.code,{children:"StateHasChanged()"})," is called exclusively on components subscribed to state changes."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"No Base Classes or Global Event Listeners:"})," Avoids global re-renders and boilerplate base class inheritance, giving you fine-grained control over component rendering and event subscription without forcing you into base classes."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Automatic Listener Disposal:"})," Event listeners are automatically tracked and disposed with the component lifecycle, preventing memory leaks and dangling references."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsxs)(t.strong,{children:["Transient ",(0,r.jsx)(t.code,{children:"IStatePulse"})," Service:"]})," Each component gets its own ",(0,r.jsx)(t.code,{children:"IStatePulse"})," instance, isolating event subscriptions and making state updates scoped and efficient."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"benchmark",children:"Benchmark"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Method"}),(0,r.jsx)(t.th,{style:{textAlign:"right"},children:"Mean"}),(0,r.jsx)(t.th,{style:{textAlign:"right"},children:"Error"}),(0,r.jsx)(t.th,{style:{textAlign:"right"},children:"StdDev"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"StatePulse_Dispatch"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"2.463 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.0161 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.0134 \u03bcs"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"StatePulse_SafeDispatch"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"3.838 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.0712 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.1501 \u03bcs"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"StatePulse_BusrtDispatch"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"332.804 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"6.0721 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"5.3828 \u03bcs"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"StatePulse_BusrtSafeDispatch"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"376.511 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"7.4720 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"14.3960 \u03bcs"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"StatePulse_FireYieldDispatch"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"3.353 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.0669 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.1702 \u03bcs"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"StatePulse_FireYield_SequentialEffectsDispatch"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"3.235 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.0367 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.0307 \u03bcs"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"StatePulse_AwaitedDispatch"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"3.292 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.0470 \u03bcs"}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:"0.0417 \u03bcs"})]})]})]}),"\n",(0,r.jsx)(t.p,{children:"StatePulse delivers strong performance given its feature set, but it\u2019s not designed for tight, high\u2011frequency loops. Long\u2011term performance improvements are planned, as there are several areas with optimization potential. For now, the priority remains system stability, configuration robustness, and feature completeness."}),"\n",(0,r.jsx)(t.h2,{id:"-installation--setup",children:"\ud83d\udce6 Installation & Setup"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Install-Package StatePulse.Net\r\n\r\ndotnet add package StatePulse.Net\r\n\n"})}),"\n",(0,r.jsx)(t.h3,{id:"3-ways-to-register-services",children:"3 Ways to Register Services"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Method 1"}),(0,r.jsx)(t.br,{}),"\n","The most deterministic and explicit registration approach. This method avoids \u201cmagic\u201d and one\u2011liners by requiring you to manually add all Reducers, Effects, Middlewares, Validators, and Actions. It provides full clarity and control over what the system loads."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"    ServiceCollection.AddStatePulseServices(o =>\r\n    {\r\n        o.AutoRegisterTypes = [\r\n                typeof(MainMenuLoaderStartAction),\r\n                typeof(MainMenuLoaderStopAction),\r\n                typeof(MainMenuLoadNavigationItemsAction),\r\n                typeof(MainMenuLoadNavigationItemsResultAction),\r\n                typeof(MainMenuOpenAction),\r\n                typeof(ProfileCardDefineAction),\r\n                typeof(ProfileCardDefineResultAction),\r\n                typeof(ProfileCardLoaderStartAction),\r\n                typeof(ProfileCardLoaderStopAction),\r\n                typeof(UpdateCounterAction),\r\n                typeof(ProfileCardDefineEffect),\r\n                typeof(ProfileCardDefineResultAction),\r\n                typeof(MainMenuLoadNavigationItemsEffect),\r\n                typeof(MainMenuOpenEffect),\r\n                typeof(MainMenuOpenEffectValidation),\r\n                typeof(ProfileCardDefineActionValidator),\r\n                typeof(MainMenuLoaderStartReducer),\r\n                typeof(MainMenuLoaderStopReducer),\r\n                typeof(MainMenuLoadNavigationItemsResultReducer),\r\n                typeof(MainMenuOpenReducer),\r\n                typeof(ProfileCardDefineResultReducer),\r\n                typeof(UpdateCounterReducer),\r\n                typeof(ProfileCardState),\r\n                typeof(MainMenuState),\r\n                typeof(CounterState),\r\n            ];\r\n    });\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Method 2"}),(0,r.jsx)(t.br,{}),"\n","This is also very explicit since v2+ we have a single entry ",(0,r.jsx)(t.code,{children:"AddStatePulseService"})," for all statepulse types (Reducers, Effects, Middlewares, Validators, and Actions)."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"    ServiceCollection.AddStatePulseServices();\r\n    ServiceCollection.AddStatePulseService<MainMenuLoaderStartAction>();\r\n    ServiceCollection.AddStatePulseService<MainMenuLoaderStopAction>();\r\n    ServiceCollection.AddStatePulseService<MainMenuLoadNavigationItemsAction>();\r\n    ServiceCollection.AddStatePulseService<MainMenuLoadNavigationItemsResultAction>();\r\n    ServiceCollection.AddStatePulseService<MainMenuOpenAction>();\r\n    ServiceCollection.AddStatePulseService<ProfileCardDefineAction>();\r\n    ServiceCollection.AddStatePulseService<ProfileCardDefineResultAction>();\r\n    ServiceCollection.AddStatePulseService<ProfileCardLoaderStartAction>();\r\n    ServiceCollection.AddStatePulseService<ProfileCardLoaderStopAction>();\r\n    ServiceCollection.AddStatePulseService<UpdateCounterAction>();\r\n    ServiceCollection.AddStatePulseService<ProfileCardDefineEffect>();\r\n    ServiceCollection.AddStatePulseService<MainMenuLoadNavigationItemsEffect>();\r\n    ServiceCollection.AddStatePulseService<MainMenuOpenEffect>();\r\n\r\n    ServiceCollection.AddStatePulseService<MainMenuOpenEffectValidation>();\r\n    ServiceCollection.AddStatePulseService<ProfileCardDefineActionValidator>();\r\n\r\n    ServiceCollection.AddStatePulseService<MainMenuLoaderStartReducer>();\r\n    ServiceCollection.AddStatePulseService<MainMenuLoaderStopReducer>();\r\n    ServiceCollection.AddStatePulseService<MainMenuLoadNavigationItemsResultReducer>();\r\n    ServiceCollection.AddStatePulseService<MainMenuOpenReducer>();\r\n    ServiceCollection.AddStatePulseService<ProfileCardDefineResultReducer>();\r\n    ServiceCollection.AddStatePulseService<UpdateCounterReducer>();\r\n    ServiceCollection.AddStatePulseService<ProfileCardState>();\r\n    ServiceCollection.AddStatePulseService<MainMenuState>();\r\n\r\n    ServiceCollection.AddStatePulseService<CounterState>();\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Method 3"}),"\r\nThe assembly-scan approach. Convenient but not recommended for most scenarios. While useful for rapid setup, it can introduce problems as system grows."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"    ServiceCollection.AddStatePulseServices(o => {\r\n        o.ScanAssemblies = [typeof(TestBase).Assembly];\r\n    });\n"})}),"\n",(0,r.jsx)(t.h2,{id:"-how-it-works",children:"\ud83e\udded How It Works"}),"\n",(0,r.jsxs)(t.h3,{id:"define-actions",children:[(0,r.jsx)(t.strong,{children:"Define Actions"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"\r\n// IAction { }\r\n// ISafeAction { } // Cannot be dispatched unsafely\r\n\r\npublic record ProfileCardDefineAction : IAction\r\n{\r\n    public string? TestData { get; set; }\r\n}\r\n\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"define-effect",children:[(0,r.jsx)(t.strong,{children:"Define Effect"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'\r\ninternal class ProfileCardDefineEffect : IEffect<ProfileCardDefineAction>\r\n{\r\n\r\n    public ProfileCardDefineEffect()\r\n    {\r\n    }\r\n    public async Task EffectAsync(ProfileCardDefineAction action, IDispatcher dispatcher)\r\n    {\r\n        var random = new Random();\r\n        int value = random.Next(100, 1001); // Upper bound is exclusive, so use 1001\r\n        await Task.Delay(value);\r\n        var myProfile = new UserResponse();\r\n        await dispatcher.Prepare(() => new ProfileCardDefineResultAction(action.TestData ?? myProfile.Name, myProfile.Picture, myProfile.Id))\r\n            .DispatchAsync();\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n### **Define Effect Validator** (Optional):\r\n\r\n```csharp\r\n/*\r\n* This is the best way to define clean conditional effects, it either run or not... this is not meant for triggering errors.\r\n* This is meant for optional/condition effects to either run or not base on the action settings...\r\n*/\r\ninternal class ProfileCardDefineActionValidator : IEffectValidator<ProfileCardDefineAction, ProfileCardDefineEffect>\r\n{\r\n    public Task<bool> Validate(ProfileCardDefineAction action)\r\n    {\r\n        if (action.TestData == "Error")\r\n            return Task.FromResult(false);\r\n        return Task.FromResult(true);\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"\r\n### **Define Reducer**:\r\n\r\n```csharp\r\ninternal class ProfileCardDefineResultReducer : IReducer<ProfileCardState, ProfileCardDefineResultAction>\r\n{\r\n    public Task<ProfileCardState> ReduceAsync(ProfileCardState state, ProfileCardDefineResultAction action)\r\n        => Task.FromResult(state with\r\n        {\r\n            LastUpdate = DateTime.UtcNow,\r\n            ProfileId = action.Id,\r\n            ProfileName = action.Name,\r\n            ProfilePicture = action.Picture\r\n        });\r\n}\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"define-statefeature",children:[(0,r.jsx)(t.strong,{children:"Define StateFeature"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public record ProfileCardState : IStateFeature\r\n{\r\n    public string? ProfileName { get; set; }\r\n    public string? ProfilePicture { get; set; }\r\n    public string? ProfileId { get; set; }\r\n    public DateTime LastUpdate { get; set; } = DateTime.UtcNow;\r\n}\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"trigger-dispatch",children:[(0,r.jsx)(t.strong,{children:"Trigger Dispatch"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"var dispatcher = ServiceProvider.GetRequiredService<IDispatcher>();\r\nvar stateAccessor = ServiceProvider.GetRequiredService<IStateAccessor<ProfileCardState>>();\r\nawait dispatcher.Prepare<ProfileCardDefineAction>().With(p => p.TestData, name)\r\n    .DispatchAsync();\r\n\r\n// You can Capture the validation in case of failure, only call if validators exist.\r\nValidationResult? validation = default;\r\nawait dispatcher.Prepare<ProfileCardDefineAction>().With(p => p.TestData, name)\r\n    .HandleActionValidation(p => validation = p)\r\n    .DispatchAsync();\r\n\r\n// You can trigger synchronously... this will await the whole pipeline, otherwise you just await until action is send to dispatch pool.\r\nawait dispatcher.Prepare<ProfileCardDefineAction>().With(p => p.TestData, name)\r\n    .Sync()\r\n    .DispatchAsync();\r\n\r\n// if the action is implementing ISafeState, the dispatch will always run asSafe=true but an action not implementing ISafeAction will\r\n// have the option to run asSafe or not...\r\nawait dispatcher.Prepare<ProfileCardDefineAction>().With(p => p.TestData, name)\r\n    .DispatchAsync(true);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"important-notes",children:"Important Notes"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Rule of thumb is always await dispatch calls, avoiding to do so can cause inconsistency for safe dispatch mode.."}),"\n",(0,r.jsx)(t.li,{children:"ISafeAction implementations are always dispatched safely, ignoring unsafe flag."}),"\n",(0,r.jsx)(t.li,{children:"synchronous is an anti-pattern of statemanement use it sparingly; it is primarily for debugging or specific scenarios requiring full completion before continuation."}),"\n"]}),"\n",(0,r.jsxs)(t.h3,{id:"access-state",children:[(0,r.jsx)(t.strong,{children:"Access State"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"var stateAccessor = ServiceProvider.GetRequiredService<IStateAccessor<ProfileCardState>>();\n"})}),"\n",(0,r.jsx)(t.h3,{id:"blazor-example-usage",children:"Blazor Example Usage"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"using StatePulse.Net;\r\n\r\npublic partial class CounterView : ComponentBase\r\n{\r\n\r\n    // METHOD 1:\r\n    [Inject] public IStatePulse PulseState { get; set; } = default!; // Handles State Accessor\r\n\r\n    // This is for convienience always use this method or directly PulseState.StateOf<CounterState>(this).Value\r\n    // Never assign State Instance variable as it will not update... \r\n    // Never use lambda it will throw exception as WeakREference is fundamatally flawed and disposes of lambda even when its object is alive.\r\n    private CounterState state => PulseState.StateOf<CounterState>(()=>this, OnUpdate);\r\n    \r\n    private async Task OnUpdate() => await InvokeAsync(StateHadChanged);\r\n\r\n    // METHOD 2: \r\n    // Inject direct state but injecting the state directly requires you to handle onchanged events by sub/unsub in lifecycle\r\n    // Or to create a basecomponent system similar to other state management systems.\r\n    [Inject] public IStateAccessor<CounterState> State { get; set; } = default!; \r\n\r\n    \r\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var i=n(6540);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);