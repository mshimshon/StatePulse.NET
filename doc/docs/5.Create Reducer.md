---
slug: gs-the-reducer
title: The Reducers
tags: [blazor, reducer, state-management, pure-functions, async, statepulse, csharp, .net]
sidebar_position: 6
---

## ğŸ”„ Reducers â€“ Pure State Updates

A **reducer** is a pure function that updates a specific part of the state in response to an action.

### âœ¨ Key Principles

Reducers:

- Take the **current state** and an **action**
- Return a **new state**
- Must be **pure** â€” no side effects, service calls, or randomness
- Are called **after effects**, if any exist


### ğŸš« Async Tips

Reducers may return `Task<TState>`, but should **avoid unnecessary `await`**. 

```csharp title="IncrementReducer.cs"
internal class IncrementReducer : IReducer<CounterState, IncrementCounterResultAction>
{
    public Task<CounterState> ReduceAsync(CounterState state, IncrementCounterResultAction action)
    => Task.FromResult(state with
    {
        Count = action.Count
    });
}
```


## âš™ï¸ What are Reducer Middlewares?

StatePulse uses **middleware interfaces** to tap into the lifecycle of **effects**, **reducers**, and **dispatches**.  
These middleware hooks are useful for **logging**, **metrics**, **analytics**, or **debugging** â€” but should **never alter behavior** or mutate state.

> â— Middleware is observational only â€” do not use it to change logic or outcomes.

`IReducerMiddleware` allows you to hook into the execution of any effect.

### Available Hooks

- `BeforeReducing(object state, object action)` â€“ called **before** the reducer runs
- `AfterReducing(object state, object action)` â€“ called **after** the reducer runs

### Example: Reducer Middleware

```csharp title="LoggingReducerMiddleware.cs"
internal class LoggingReducerMiddleware : IReducerMiddleware
{
    public Task AfterReducing(object state, object action)
    {
        Console.WriteLine($"{action.GetType().Name} Executed.");
        return Task.CompletedTask;
    }

    public Task BeforeReducing(object state, object action)
    {
        Console.WriteLine($"{state.GetType().Name} {action.GetType().Name} Executed.");
        return Task.CompletedTask;
    }
}
```