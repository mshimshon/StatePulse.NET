---
slug: setup-blazor-project
title: Setup Blazor Project
tags: [blazor, setup, installation, statepulse, dependency-injection, csharp, .net]
sidebar_position: 2
---


## ðŸ“¦ Installation & Setup

```bash
Install-Package StatePulse.Net

dotnet add package StatePulse.Net

```

Add to ```Program.cs```: 
```cs
builder.Services.AddStatePulseServices();
```

Create StatePulse common folder structure.
```
/Pulses/
/Pulses/Counter <- Feature
/Pulses/Counter/Actions
/Pulses/Counter/Effects
/Pulses/Counter/Effects/Validators
/Pulses/Counter/Reducers
/Pulses/Counter/Stores
```

This structure is complete and very common pattern.

## Add Services
**Method 1**  
The most deterministic and explicit registration approach. This method avoids â€œmagicâ€ and oneâ€‘liners by requiring you to manually add all Reducers, Effects, Middlewares, Validators, and Actions. It provides full clarity and control over what the system loads.

```csharp
    ServiceCollection.AddStatePulseServices(o =>
    {
        o.AutoRegisterTypes = [
                typeof(WHATEVER_STATEPULSE_TYPE),
            ];
    });
```

**Method 2**  
This is also very explicit since v2+ we have a single entry `AddStatePulseService` for all statepulse types (Reducers, Effects, Middlewares, Validators, and Actions).

```csharp
    ServiceCollection.AddStatePulseServices(); // Register Base Services
    ServiceCollection.AddStatePulseService<WHATEVER_STATEPULSE_TYPE>();
```

**Method 3**
The assembly-scan approach. Convenient but not recommended for most scenarios. While useful for rapid setup, it can introduce problems as system grows.

```csharp
    ServiceCollection.AddStatePulseServices(o => {
        o.ScanAssemblies = [typeof(TestBase).Assembly];
    });
```
*Note: The assembly scan doesn't get along well with unit testing.*
