---
slug: versions
title: Updates
sidebar_position: 0
---

## ğŸ“¦ v2.0.0
### âœ¨ BREAKING CHANGES
### âœ¨ BREAKING CHANGES

- **Interface signatures have changed.**  
   Core interface updates may break pluginâ€‘based systems if the core updates while plugins do not.  
   This is only safe when proper plugin isolation is respected.

- **Reducers now run before effects.**  
   The default dispatch order has changed.  
   Pipelines that rely on reducers running after effects must update their configuration to restore the previous behavior.

- **Middleware between individual effects has been removed.**  
   Perâ€‘effect middleware proved unreliable and is no longer supported.  
   All effects now run as a batch, followed by a single AfterEffect phase.  
   Middleware can still be awaited before the BeforeEffect phase and after the AfterEffect phase.

### âœ¨ New Features
- **âš™ï¸ Enhanced Configuration Options** - New global configuration properties:
  - `DispatchOrderBehavior` - Set default ordering (EffectsFirst/ReducersFirst)
  - `DispatchEffectExecutionBehavior` - Set default execution mode (YieldAndFire/FireAndForget)
- **ğŸ›ï¸ Configurable Dispatch Ordering** - Choose between `EffectsFirst` (default) or `ReducersFirst` execution order globally or per-dispatch
- **âš¡ True Fire-and-Forget Execution Mode** - New `DispatchEffectExecutionBehavior.FireAndForget` for true background execution without yielding and awaiting effects
- **ğŸ”§ Per-Dispatch Execution Control** - Override global settings per dispatch with fluent API:
  - `.ExecFireAndForget()` - Fully detached background execution
  - `.ExecYieldAndFire()` - Yield to caller but await until all effects are done to move down the pipeline
  - `.EffectsFirst()` - Run effects before reducers
  - `.ReducersFirst()` - Run reducers before effects
  - `.SequentialEffects()` - Force effects to run in sequence
  - `.ParallelEffects()` - Force effects to run in parallel
- **ğŸ›¡ï¸ Invalid Configuration Detection** - New `InvalidDispatchCombinationException` thrown at dispatch time for incompatible configuration combinations (Plan to generate compiler errors later)
- **â™»ï¸ Recursive Dispatch Support** - Fire-and-forget mode enables safe recursive dispatch patterns without deadlocks
- `PulseTrackingModel` - Clear option for the tracking model! Either Thread-Safe (`Default`) or Single Threaded Fast Application... WASM/Blazor Server.
- `GlobalTrackerLifetime` - Define clearly lifetime scope for the Global Tracker singleton or scoped. `BlazorServer`, `WASM`, `Scoped` (Default) or `Singleton`.
- `IStateFeatureSingleton` - Define a singleton state across your app... not useful in WASM but very useful in Blazor Server... where one can share the state across client each client run their own action but the state update spread across all circuits.

### ğŸ Fixes
- Fixed Various Warnings
- Fixed All Configure Internal... 


## ğŸ“¦ v1.1.0
### âœ¨ Minor Change
- Upgraded to .NET 10

## ğŸ“¦ v1.0.2
### ğŸ Fixes
- Added StatePulse.Net.Abstractions package reference instead of project reference to fix IL trimming issues.

## ğŸ“¦ v1.0.1
### âœ¨ Minor Change
- Splited Abstractions into StatePulse.Net.Abstractions (Will not break anything Namespace is the same)


## ğŸ“¦ v1.0.0
### âœ¨ New Features

- âœ… **Action Effect Validator**: Allows effects to run conditionally by validating them before execution.
- ğŸ§© **Middleware Support**:
  - `IEffectMiddleware`
  - `IReducerMiddleware`
  - `IDispatchMiddleware`
- âš™ï¸ **Behavior Configuration**: You can configure execution behaviors via:
  - `DispatchEffectBehavior`
  - `MiddlewareEffectBehavior`
  - `MiddlewareTaskBehavior`
- ğŸ› ï¸ **Strict Manual Registration**: Manual service registration **must use** extension methods:
  - `AddStatePulse()`
  - `AddStatePulseEffect<>()`
  - `AddStatePulseAction<>()`
  - `AddStatePulseReducer<>()`
  - `AddStatePulseStateFeature<>()`
  - `AddStatePulseEffectValidator<>()`

### ğŸ’¥ Breaking Changes

- âŒ Removed **Action Validator** â€“ validating action data is not the responsibility of the state management layer.
- ğŸ”„ Renamed:
  - `IStateAccessor<>.StateChanged` â†’ `OnStateChanged`
  - `UsingSynchronousMode` â†’ **Removed**
  - `Sync()` â†’ `Await()` for clarity and accuracy

### ğŸš€ Performance Improvements

- ğŸ§  Improved **dispatcher caching**
- âš¡ Enhanced **type cache** in `StatePulseRegistry`
- ğŸ§¬ Replaced reflection with **dynamic method caching** for faster dispatching

### ğŸ§¼ Clean Code Improvements

- ğŸ§¹ Refactored `DispatchPrepper` for cleaner and lighter internal logic

### ğŸ Fixes

- ğŸ› ï¸ Resolved several **null reference warnings**
- ğŸ§½ Removed leftover **internal artifacts**

## v0.9.41
- Fix: Added Anti-Service duplication to avoid double triggers.

## v0.9.4
- Breaking Change, StateOf no longer accept lambda will throw exception you must define a Task directly... this was necessary due to Garbage Collector and tracking behavior.
- Deprecated UsingSynchronousMode() instead use Sync().

## v0.9.21
- Implement the Blazor Package and removed dependencies to Blazor ComponentBase which is no longer required... 
- Any objects within .NET can now use IStatePulse and benefit from state management without extra implementations.
- Renamed IPulse to IStatePulse
- ```using IStatePulse.StateOf(()=>this, () => InvokeAsync(StateHasChanged));```


## v0.9.2 (Blazor Packages)
- Deprecated now part of StatePulse regular since we have removed the dependencies to blazor component.
... that was quick!


