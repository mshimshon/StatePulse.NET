---
slug: versions
title: Updates
sidebar_position: 0
---

## ğŸ“¦ v2.0.0
### âœ¨ BREAKING CHANGES
- The signature of interfaces changed so any plugin-based system could potentially break if core updates and plugins don't unless plugin isolation is respected.
- The REDUCERS now run before the effects! so any pipelines relying on post-effect reducers should configure StatePulse to execute reducers post effect (simple config flip) `Configure.DispatchOrderBehavior = DispatchOrdering.EffectsFirst;`.

### âœ¨ New Features
- **âš™ï¸ Enhanced Configuration Options** - New global configuration properties:
  - `DispatchOrderBehavior` - Set default ordering (EffectsFirst/ReducersFirst)
  - `DispatchEffectExecutionBehavior` - Set default execution mode (YieldAndFire/FireAndForget)
- **ğŸ›ï¸ Configurable Dispatch Ordering** - Choose between `EffectsFirst` (default) or `ReducersFirst` execution order globally or per-dispatch
- **âš¡ True Fire-and-Forget Execution Mode** - New `DispatchEffectExecutionBehavior.FireAndForget` for true background execution without yielding and awaiting effects
- **ğŸ”§ Per-Dispatch Execution Control** - Override global settings per dispatch with fluent API:
  - `.ExecFireAndForget()` - Fully detached background execution
  - `.ExecYieldAndFire()` - Yield to caller but await until all effects are done to move down the pipeline
  - `.EffectsFirst()` - Run effects before reducers
  - `.ReducersFirst()` - Run reducers before effects
  - `.SequentialEffects()` - Force effects to run in sequence
  - `.ParallelEffects()` - Force effects to run in parallel
- **ğŸ›¡ï¸ Invalid Configuration Detection** - New `InvalidDispatchCombinationException` thrown at dispatch time for incompatible configuration combinations (Plan to generate compiler errors later)
- **â™»ï¸ Recursive Dispatch Support** - Fire-and-forget mode enables safe recursive dispatch patterns without deadlocks


## ğŸ“¦ v1.1.0
### âœ¨ Minor Change
- Upgraded to .NET 10

## ğŸ“¦ v1.0.2
### ğŸ Fixes
- Added StatePulse.Net.Abstractions package reference instead of project reference to fix IL trimming issues.

## ğŸ“¦ v1.0.1
### âœ¨ Minor Change
- Splited Abstractions into StatePulse.Net.Abstractions (Will not break anything Namespace is the same)


## ğŸ“¦ v1.0.0
### âœ¨ New Features

- âœ… **Action Effect Validator**: Allows effects to run conditionally by validating them before execution.
- ğŸ§© **Middleware Support**:
  - `IEffectMiddleware`
  - `IReducerMiddleware`
  - `IDispatchMiddleware`
- âš™ï¸ **Behavior Configuration**: You can configure execution behaviors via:
  - `DispatchEffectBehavior`
  - `MiddlewareEffectBehavior`
  - `MiddlewareTaskBehavior`
- ğŸ› ï¸ **Strict Manual Registration**: Manual service registration **must use** extension methods:
  - `AddStatePulse()`
  - `AddStatePulseEffect<>()`
  - `AddStatePulseAction<>()`
  - `AddStatePulseReducer<>()`
  - `AddStatePulseStateFeature<>()`
  - `AddStatePulseEffectValidator<>()`

### ğŸ’¥ Breaking Changes

- âŒ Removed **Action Validator** â€“ validating action data is not the responsibility of the state management layer.
- ğŸ”„ Renamed:
  - `IStateAccessor<>.StateChanged` â†’ `OnStateChanged`
  - `UsingSynchronousMode` â†’ **Removed**
  - `Sync()` â†’ `Await()` for clarity and accuracy

### ğŸš€ Performance Improvements

- ğŸ§  Improved **dispatcher caching**
- âš¡ Enhanced **type cache** in `StatePulseRegistry`
- ğŸ§¬ Replaced reflection with **dynamic method caching** for faster dispatching

### ğŸ§¼ Clean Code Improvements

- ğŸ§¹ Refactored `DispatchPrepper` for cleaner and lighter internal logic

### ğŸ Fixes

- ğŸ› ï¸ Resolved several **null reference warnings**
- ğŸ§½ Removed leftover **internal artifacts**

## v0.9.41
- Fix: Added Anti-Service duplication to avoid double triggers.

## v0.9.4
- Breaking Change, StateOf no longer accept lambda will throw exception you must define a Task directly... this was necessary due to Garbage Collector and tracking behavior.
- Deprecated UsingSynchronousMode() instead use Sync().

## v0.9.21
- Implement the Blazor Package and removed dependencies to Blazor ComponentBase which is no longer required... 
- Any objects within .NET can now use IStatePulse and benefit from state management without extra implementations.
- Renamed IPulse to IStatePulse
- ```using IStatePulse.StateOf(()=>this, () => InvokeAsync(StateHasChanged));```


## v0.9.2 (Blazor Packages)
- Deprecated now part of StatePulse regular since we have removed the dependencies to blazor component.
... that was quick!


