"use strict";(self.webpackChunkstatepulse_doc=self.webpackChunkstatepulse_doc||[]).push([[7778],{4661:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Getting Started","title":"Get Started","description":"License: MIT","source":"@site/docs/Getting Started.md","sourceDirName":".","slug":"/","permalink":"/","draft":false,"unlisted":false,"editUrl":"https://github.com/mshimshon/StatePulse.NET/docs/Getting Started.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"slug":"/","title":"Get Started","sidebar_position":0},"sidebar":"tutorialSidebar","next":{"title":"Setup Blazor Project","permalink":"/setup-blazor-project"}}');var r=t(4848),a=t(8453);const s={slug:"/",title:"Get Started",sidebar_position:0},o="StatePulse.NET",l={},c=[{value:"Official Documentation",id:"official-documentation",level:3},{value:"\u2728 Features",id:"-features",level:2},{value:"\ud83d\ude80 <strong>State Management with Zero Boilerplate and Zero Compromises</strong>",id:"-state-management-with-zero-boilerplate-and-zero-compromises",level:3},{value:"\ud83d\udce6 Installation &amp; Setup",id:"-installation--setup",level:2},{value:"\ud83e\udded How It Works",id:"-how-it-works",level:2},{value:"<strong>Define Actions</strong>:",id:"define-actions",level:3},{value:"<strong>Define Actions Validator</strong> (Optional):",id:"define-actions-validator-optional",level:3},{value:"<strong>Define Effect</strong>:",id:"define-effect",level:3},{value:"<strong>Define Reducer</strong>:",id:"define-reducer",level:3},{value:"<strong>Define StateFeature</strong>:",id:"define-statefeature",level:3},{value:"<strong>Trigger Dispatch</strong>:",id:"trigger-dispatch",level:3},{value:"Important Notes",id:"important-notes",level:3},{value:"<strong>Access State</strong>:",id:"access-state",level:3},{value:"Blazor Example Usage",id:"blazor-example-usage",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://opensource.org/licenses/MIT",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/badge/License-MIT-brightgreen.svg",alt:"License: MIT"})}),"\r\n",(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/StatePulse.NET",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/nuget/v/StatePulse.Net",alt:"NuGet Version"})}),"\r\n",(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/StatePulse.NET",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/StatePulse.NET?label=Downloads",alt:""})})]}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"statepulsenet",children:"StatePulse.NET"})}),"\n",(0,r.jsx)(n.h3,{id:"official-documentation",children:(0,r.jsx)(n.a,{href:"https://statepulse.net/",children:"Official Documentation"})}),"\n",(0,r.jsx)(n.p,{children:"StatePulse.NET is a precision-tuned state and action management system that balances high-performance fire-and-forget operations with optional, internally controlled execution order when explicitly required.\r\nIt enables anti-duplication chaining for critical flows, preventing race conditions and ensuring consistent outcomes even under rapid user input or concurrent triggers.\r\nIts internal tracking infrastructure provides near-zero overhead cancellation and dispatch control, drastically reducing inconsistency.\r\nAt the same time, it preserves the flexibility of traditional untracked state management, letting developers selectively enforce order and reliability without compromising overall responsiveness or introducing global locks."}),"\n",(0,r.jsx)(n.h2,{id:"-features",children:"\u2728 Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u26a1 ",(0,r.jsx)(n.strong,{children:"Fast Fire-and-Forget"})," \u2014 Executes actions immediately even tracked action are fire-and-forget."]}),"\n",(0,r.jsxs)(n.li,{children:["\ud83d\udee1 ",(0,r.jsx)(n.strong,{children:"Anti-Duplicate Dispatching"})," \u2014 Prevents redundant or overlapping actions that can cause race condition state inconsistency."]}),"\n",(0,r.jsxs)(n.li,{children:["\ud83d\udd0d ",(0,r.jsx)(n.strong,{children:"Validator System"})," \u2014 Supports multiple action validators for modular and reusable rule enforcement."]}),"\n",(0,r.jsxs)(n.li,{children:["\ud83e\uddea ",(0,r.jsx)(n.strong,{children:"Synchronous Debug Mode"})," \u2014 Optional lockstep mode for testing, diagnostics, and ",(0,r.jsx)(n.code,{children:"Task.WhenAll"})," pipelines."]}),"\n",(0,r.jsxs)(n.li,{children:["\ud83e\uddf5 ",(0,r.jsx)(n.strong,{children:"DispatchTracker"})," \u2014 High-performance cancellation and deduplication logic via optimized concurrent tracking."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"-state-management-with-zero-boilerplate-and-zero-compromises",children:["\ud83d\ude80 ",(0,r.jsx)(n.strong,{children:"State Management with Zero Boilerplate and Zero Compromises"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy State Access Model:"})," Inject ",(0,r.jsx)(n.code,{children:"IStatePulse"})," directly into your Blazor component and call ",(0,r.jsx)(n.code,{children:"StateOf<TState>(()=>this, TaskMethod)"})," to get scoped state access."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Component-Scoped Event Listening:"})," Automatically registers event listeners only for that component, ensuring ",(0,r.jsx)(n.code,{children:"StateHasChanged()"})," is called exclusively on components subscribed to state changes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Base Classes or Global Event Listeners:"})," Avoids global re-renders and boilerplate base class inheritance, giving you fine-grained control over component rendering and event subscription without forcing you into base classes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Listener Disposal:"})," Event listeners are automatically tracked and disposed with the component lifecycle, preventing memory leaks and dangling references."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Transient ",(0,r.jsx)(n.code,{children:"IStatePulse"})," Service:"]})," Each component gets its own ",(0,r.jsx)(n.code,{children:"IStatePulse"})," instance, isolating event subscriptions and making state updates scoped and efficient."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"-installation--setup",children:"\ud83d\udce6 Installation & Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Install-Package StatePulse.Net\r\n\r\ndotnet add package StatePulse.Net\r\n\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"services.AddStatePulseServices(o =>\r\n        {\r\n            o.ScanAssemblies = new Type[] { typeof(Program) };\r\n        });\n"})}),"\n",(0,r.jsx)(n.h2,{id:"-how-it-works",children:"\ud83e\udded How It Works"}),"\n",(0,r.jsxs)(n.h3,{id:"define-actions",children:[(0,r.jsx)(n.strong,{children:"Define Actions"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\r\n// IAction { }\r\n// ISafeAction { } // Cannot be dispatched unsafely\r\n\r\npublic record ProfileCardDefineAction : IAction\r\n{\r\n    public string? TestData { get; set; }\r\n}\r\n\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"define-actions-validator-optional",children:[(0,r.jsx)(n.strong,{children:"Define Actions Validator"})," (Optional):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'/*\r\nYou are not required to create have an action validator but it is very useful when you have business logic that conditionally only contionally fires.\r\nWhen validation fails it ignores the dispatch and move on.\r\n*/\r\ninternal class ProfileCardDefineActionValidator : IActionValidator<ProfileCardDefineAction>\r\n{\r\n    public void Validate(ProfileCardDefineAction action, ref ValidationResult result)\r\n    {\r\n        if (action.TestData == "Error")\r\n            result.AddError("ErrorName", "Name Cannot be Error");\r\n    }\r\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"define-effect",children:[(0,r.jsx)(n.strong,{children:"Define Effect"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\r\ninternal class ProfileCardDefineEffect : IEffect<ProfileCardDefineAction>\r\n{\r\n\r\n    public ProfileCardDefineEffect()\r\n    {\r\n    }\r\n    public async Task EffectAsync(ProfileCardDefineAction action, IDispatcher dispatcher)\r\n    {\r\n        var random = new Random();\r\n        int value = random.Next(100, 1001); // Upper bound is exclusive, so use 1001\r\n        await Task.Delay(value);\r\n        var myProfile = new UserResponse();\r\n        await dispatcher.Prepare(() => new ProfileCardDefineResultAction(action.TestData ?? myProfile.Name, myProfile.Picture, myProfile.Id))\r\n            .DispatchAsync();\r\n    }\r\n\r\n}\r\n\r\n\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"define-reducer",children:[(0,r.jsx)(n.strong,{children:"Define Reducer"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"internal class ProfileCardDefineResultReducer : IReducer<ProfileCardState, ProfileCardDefineResultAction>\r\n{\r\n    public Task<ProfileCardState> ReduceAsync(ProfileCardState state, ProfileCardDefineResultAction action)\r\n        => Task.FromResult(state with\r\n        {\r\n            LastUpdate = DateTime.UtcNow,\r\n            ProfileId = action.Id,\r\n            ProfileName = action.Name,\r\n            ProfilePicture = action.Picture\r\n        });\r\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"define-statefeature",children:[(0,r.jsx)(n.strong,{children:"Define StateFeature"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public record ProfileCardState : IStateFeature\r\n{\r\n    public string? ProfileName { get; set; }\r\n    public string? ProfilePicture { get; set; }\r\n    public string? ProfileId { get; set; }\r\n    public DateTime LastUpdate { get; set; } = DateTime.UtcNow;\r\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"trigger-dispatch",children:[(0,r.jsx)(n.strong,{children:"Trigger Dispatch"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"var dispatcher = ServiceProvider.GetRequiredService<IDispatcher>();\r\nvar stateAccessor = ServiceProvider.GetRequiredService<IStateAccessor<ProfileCardState>>();\r\nawait dispatcher.Prepare<ProfileCardDefineAction>().With(p => p.TestData, name)\r\n    .DispatchAsync();\r\n\r\n// You can Capture the validation in case of failure, only call if validators exist.\r\nValidationResult? validation = default;\r\nawait dispatcher.Prepare<ProfileCardDefineAction>().With(p => p.TestData, name)\r\n    .HandleActionValidation(p => validation = p)\r\n    .DispatchAsync();\r\n\r\n// You can trigger synchronously... this will await the whole pipeline, otherwise you just await until action is send to dispatch pool.\r\nawait dispatcher.Prepare<ProfileCardDefineAction>().With(p => p.TestData, name)\r\n    .Sync()\r\n    .DispatchAsync();\r\n\r\n// if the action is implementing ISafeState, the dispatch will always run asSafe=true but an action not implementing ISafeAction will\r\n// have the option to run asSafe or not...\r\nawait dispatcher.Prepare<ProfileCardDefineAction>().With(p => p.TestData, name)\r\n    .DispatchAsync(true);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"important-notes",children:"Important Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rule of thumb is always await dispatch calls, avoiding to do so can cause inconsistency for safe dispatch mode.."}),"\n",(0,r.jsx)(n.li,{children:"ISafeAction implementations are always dispatched safely, ignoring unsafe flags."}),"\n",(0,r.jsx)(n.li,{children:"synchronous is an anti-pattern of statemanement use it sparingly; it is primarily for debugging or specific scenarios requiring full completion before continuation."}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"access-state",children:[(0,r.jsx)(n.strong,{children:"Access State"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"var stateAccessor = ServiceProvider.GetRequiredService<IStateAccessor<ProfileCardState>>();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"blazor-example-usage",children:"Blazor Example Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using StatePulse.Net;\r\n\r\npublic partial class CounterView : ComponentBase\r\n{\r\n\r\n    // METHOD 1:\r\n    [Inject] public IStatePulse PulseState { get; set; } = default!; // Handles State Accessor\r\n\r\n    // This is for convienience always use this method or directly PulseState.StateOf<CounterState>(this).Value\r\n    // Never assign State Instance variable as it will not update... \r\n    // Never use lambda it will throw exception as WeakREference is fundamatally flawed and disposes of lambda even when its object is alive.\r\n    private CounterState state => PulseState.StateOf<CounterState>(()=>this, OnUpdate);\r\n    \r\n    private async Task OnUpdate() => await InvokeAsync(StateHadChanged);\r\n\r\n    // METHOD 2: \r\n    // Inject direct state but injecting the state directly requires you to handle onchanged events by sub/unsub in lifecycle\r\n    // Or to create a basecomponent system similar to other state management systems.\r\n    [Inject] public IStateAccessor<CounterState> State { get; set; } = default!; \r\n\r\n    \r\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);