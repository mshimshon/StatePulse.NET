"use strict";(self.webpackChunkstatepulse_doc=self.webpackChunkstatepulse_doc||[]).push([[7698],{7272:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"4 Create Effects","title":"Create Effects","description":"Effects \u2013 Executing Logic Before State Updates","source":"@site/docs/4 Create Effects.md","sourceDirName":".","slug":"/gs-create-effect","permalink":"/gs-create-effect","draft":false,"unlisted":false,"editUrl":"https://github.com/mshimshon/StatePulse.NET/docs/4 Create Effects.md","tags":[{"inline":true,"label":"blazor","permalink":"/tags/blazor"},{"inline":true,"label":"effects","permalink":"/tags/effects"},{"inline":true,"label":"state-management","permalink":"/tags/state-management"},{"inline":true,"label":"async","permalink":"/tags/async"},{"inline":true,"label":"side-effects","permalink":"/tags/side-effects"},{"inline":true,"label":"statepulse","permalink":"/tags/statepulse"},{"inline":true,"label":"csharp","permalink":"/tags/csharp"},{"inline":true,"label":".net","permalink":"/tags/net"}],"version":"current","sidebarPosition":4,"frontMatter":{"slug":"gs-create-effect","title":"Create Effects","tags":["blazor","effects","state-management","async","side-effects","statepulse","csharp",".net"],"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Create State","permalink":"/gs-create-state"},"next":{"title":"Create Reducer","permalink":"/gs-create-reducer"}}');var r=n(4848),a=n(8453);const c={slug:"gs-create-effect",title:"Create Effects",tags:["blazor","effects","state-management","async","side-effects","statepulse","csharp",".net"],sidebar_position:4},i=void 0,o={},l=[{value:"Effects \u2013 Executing Logic Before State Updates",id:"effects--executing-logic-before-state-updates",level:2},{value:"\ud83e\uddf1 Common Pattern: Request + Result",id:"-common-pattern-request--result",level:3},{value:"\ud83d\udcdb Naming Convention",id:"-naming-convention",level:3},{value:"Create The Effect",id:"create-the-effect",level:3}];function f(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"effects--executing-logic-before-state-updates",children:"Effects \u2013 Executing Logic Before State Updates"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Effects"})," are units of logic that run ",(0,r.jsx)(t.strong,{children:"in response to an action"}),", before any associated reducers are invoked."]}),"\n",(0,r.jsx)(t.p,{children:"They are commonly used for:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Performing ",(0,r.jsx)(t.strong,{children:"side effects"})," (e.g. API calls, logging, validation)"]}),"\n",(0,r.jsxs)(t.li,{children:["Dispatching ",(0,r.jsx)(t.strong,{children:"follow-up actions"})," based on results"]}),"\n",(0,r.jsxs)(t.li,{children:["Handling ",(0,r.jsx)(t.strong,{children:"asynchronous workflows"})]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"-common-pattern-request--result",children:"\ud83e\uddf1 Common Pattern: Request + Result"}),"\n",(0,r.jsx)(t.p,{children:"A typical pattern is to define:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"SomeAction"})," \u2013 the original trigger"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"SomeActionResult"})," \u2013 dispatched by the effect after the async work is done"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Reducers usually handle the ",(0,r.jsx)(t.code,{children:"Result"})," action to update the state."]}),"\n",(0,r.jsx)(t.h3,{id:"-naming-convention",children:"\ud83d\udcdb Naming Convention"}),"\n",(0,r.jsxs)(t.p,{children:["Effects are usually named using the action\u2019s name followed by the ",(0,r.jsx)(t.code,{children:"Effect"})," suffix."]}),"\n",(0,r.jsx)(t.h3,{id:"create-the-effect",children:"Create The Effect"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'title="IncrementCounterEffect.cs"',children:"internal class IncrementCounterEffect : IEffect<IncrementCounterAction>\r\n{\r\n    readonly IStateAccessor<CounterState> _counterState;\r\n    public IncrementCounterEffect(IStateAccessor<CounterState> counterState)\r\n    {\r\n        _counterState = counterState;\r\n    }\r\n    public async Task EffectAsync(IncrementCounterAction action, IDispatcher dispatcher)\r\n    {\r\n        // Recommendation: Always Await Dispatch to avoid safe execution issues, it won't block.\r\n        await dispatcher.Prepare<IncrementCounterResultAction>()\r\n            .With(p => p.Count, _counterState.State.Count + 1)\r\n            .DispatchAsync();\r\n    }\r\n}\n"})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>i});var s=n(6540);const r={},a=s.createContext(r);function c(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);