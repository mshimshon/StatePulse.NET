"use strict";(self.webpackChunkstatepulse_doc=self.webpackChunkstatepulse_doc||[]).push([[836],{8406:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorial-basics/4 Create Effects","title":"Create Effects","description":"Effects \u2013 Executing Logic Before State Updates","source":"@site/docs/tutorial-basics/4 Create Effects.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/gs-create-effect","permalink":"/tutorial-basics/gs-create-effect","draft":false,"unlisted":false,"editUrl":"https://github.com/mshimshon/StatePulse.NET/docs/tutorial-basics/4 Create Effects.md","tags":[{"inline":true,"label":"hola","permalink":"/tags/hola"},{"inline":true,"label":"docusaurus","permalink":"/tags/docusaurus"}],"version":"current","sidebarPosition":4,"frontMatter":{"slug":"gs-create-effect","title":"Create Effects","tags":["hola","docusaurus"],"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Create State","permalink":"/tutorial-basics/gs-create-state"},"next":{"title":"Create Reducer","permalink":"/tutorial-basics/Create Reducer"}}');var r=n(4848),c=n(8453);const a={slug:"gs-create-effect",title:"Create Effects",tags:["hola","docusaurus"],sidebar_position:4},i=void 0,o={},l=[{value:"Effects \u2013 Executing Logic Before State Updates",id:"effects--executing-logic-before-state-updates",level:2},{value:"\ud83e\uddf1 Common Pattern: Request + Result",id:"-common-pattern-request--result",level:3},{value:"\ud83d\udcdb Naming Convention",id:"-naming-convention",level:3},{value:"Create The Effect",id:"create-the-effect",level:3}];function u(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"effects--executing-logic-before-state-updates",children:"Effects \u2013 Executing Logic Before State Updates"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Effects"})," are units of logic that run ",(0,r.jsx)(t.strong,{children:"in response to an action"}),", before any associated reducers are invoked."]}),"\n",(0,r.jsx)(t.p,{children:"They are commonly used for:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Performing ",(0,r.jsx)(t.strong,{children:"side effects"})," (e.g. API calls, logging, validation)"]}),"\n",(0,r.jsxs)(t.li,{children:["Dispatching ",(0,r.jsx)(t.strong,{children:"follow-up actions"})," based on results"]}),"\n",(0,r.jsxs)(t.li,{children:["Handling ",(0,r.jsx)(t.strong,{children:"asynchronous workflows"})]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"-common-pattern-request--result",children:"\ud83e\uddf1 Common Pattern: Request + Result"}),"\n",(0,r.jsx)(t.p,{children:"A typical pattern is to define:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"SomeAction"})," \u2013 the original trigger"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"SomeActionResult"})," \u2013 dispatched by the effect after the async work is done"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Reducers usually handle the ",(0,r.jsx)(t.code,{children:"Result"})," action to update the state."]}),"\n",(0,r.jsx)(t.h3,{id:"-naming-convention",children:"\ud83d\udcdb Naming Convention"}),"\n",(0,r.jsxs)(t.p,{children:["Effects are usually named using the action\u2019s name followed by the ",(0,r.jsx)(t.code,{children:"Effect"})," suffix."]}),"\n",(0,r.jsx)(t.h3,{id:"create-the-effect",children:"Create The Effect"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'title="IncreamentCounterEffect.cs"',children:"internal class IncreamentCounterEffect : IEffect<IncreamentCounterAction>\r\n{\r\n    readonly IStateAccessor<CounterState> _counterState;\r\n    public IncreamentCounterEffect(IStateAccessor<CounterState> counterState)\r\n    {\r\n        _counterState = counterState;\r\n    }\r\n    public async Task EffectAsync(IncreamentCounterAction action, IDispatcher dispatcher)\r\n    {\r\n        // Recommendation: Always Await Dispatch to avoid safe execution issues, it won't block.\r\n        await dispatcher.Prepare<IncreamentCounterResultAction>()\r\n            .With(p => p.Count, _counterState.State.Count + 1)\r\n            .DispatchAsync();\r\n    }\r\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var s=n(6540);const r={},c=s.createContext(r);function a(e){const t=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(c.Provider,{value:t},e.children)}}}]);