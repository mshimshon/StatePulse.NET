"use strict";(self.webpackChunkstatepulse_doc=self.webpackChunkstatepulse_doc||[]).push([[8013],{1221:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Inject State","title":"Inject State","description":"---","source":"@site/docs/7.Inject State.md","sourceDirName":".","slug":"/Inject State","permalink":"/Inject State","draft":false,"unlisted":false,"editUrl":"https://github.com/mshimshon/StatePulse.NET/docs/7.Inject State.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Using Dispatch","permalink":"/gs-inject-dispatcher"}}');var r=n(4848),a=n(8453);const i={},o=void 0,l={},c=[{value:"slug: gs-inject-state\r\ntitle: Injecting State\r\ntags: [blazor, statepulse, state-management, reactive-ui, dispatcher, component-lifecycle, performance, async-await, reducer, event-binding]\r\nsidebar_position: 7",id:"slug-gs-inject-statetitle-injecting-statetags-blazor-statepulse-state-management-reactive-ui-dispatcher-component-lifecycle-performance-async-await-reducer-event-bindingsidebar_position-7",level:2},{value:"\ud83c\udfaf Manual State Hooking",id:"-manual-state-hooking",level:2},{value:"\u2705 Why This Is Optimal",id:"-why-this-is-optimal",level:3},{value:"\ud83c\udf00 StatePulse: Zero-Boilerplate Without Compromise",id:"-statepulse-zero-boilerplate-without-compromise",level:3},{value:"\ud83d\udee0\ufe0f Example: Manual State Hook",id:"\ufe0f-example-manual-state-hook",level:3},{value:"\ud83c\udfaf Zero-Boilerplate State Hook",id:"-zero-boilerplate-state-hook",level:2},{value:"\ud83d\ude80 Example",id:"-example",level:4}];function d(e){const t={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"slug-gs-inject-statetitle-injecting-statetags-blazor-statepulse-state-management-reactive-ui-dispatcher-component-lifecycle-performance-async-await-reducer-event-bindingsidebar_position-7",children:"slug: gs-inject-state\r\ntitle: Injecting State\r\ntags: [blazor, statepulse, state-management, reactive-ui, dispatcher, component-lifecycle, performance, async-await, reducer, event-binding]\r\nsidebar_position: 7"}),"\n",(0,r.jsx)(t.h2,{id:"-manual-state-hooking",children:"\ud83c\udfaf Manual State Hooking"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.strong,{children:"manual subscription approach"})," is the most ",(0,r.jsx)(t.strong,{children:"performant and reliable"})," way to handle state updates \u2014 in StatePulse or any other state management library."]}),"\n",(0,r.jsxs)(t.p,{children:["By ",(0,r.jsx)(t.strong,{children:"explicitly subscribing and unsubscribing"})," to a specific state, only the components that depend on that state are re-rendered.",(0,r.jsx)(t.br,{}),"\n","This avoids unnecessary rendering and offers precise control."]}),"\n",(0,r.jsx)(t.h3,{id:"-why-this-is-optimal",children:"\u2705 Why This Is Optimal"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"No overhead"})," from global tracking or base components"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Fine-grained control"})," over component updates"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Best performance"}),", especially in large apps"]}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.strong,{children:"Works without any framework-specific magic"})}),"\n"]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\u26a0\ufe0f The downside? It requires more boilerplate.",(0,r.jsx)(t.br,{}),"\n","That's why many libraries introduce alternatives like global components, wrappers, or base components \u2014 but these come with trade-offs in flexibility or overhead."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"-statepulse-zero-boilerplate-without-compromise",children:"\ud83c\udf00 StatePulse: Zero-Boilerplate Without Compromise"}),"\n",(0,r.jsxs)(t.p,{children:["StatePulse ",(0,r.jsx)(t.strong,{children:"does not force you"})," to inherit from a base component or use a global component to track state changes.",(0,r.jsx)(t.br,{}),"\n","Instead, StatePulse provides a ",(0,r.jsx)(t.strong,{children:"clever and efficient mechanism"})," to track components that request state,",(0,r.jsx)(t.br,{}),"\n","binding them automatically with:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\u2705 ",(0,r.jsx)(t.strong,{children:"Memory leak protection"})]}),"\n",(0,r.jsxs)(t.li,{children:["\u26a1 ",(0,r.jsx)(t.strong,{children:"Optimized getters"})]}),"\n",(0,r.jsxs)(t.li,{children:["\ud83e\uddfc ",(0,r.jsx)(t.strong,{children:"Zero boilerplate on your side"})]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["This ensures ",(0,r.jsx)(t.strong,{children:"no architectural compromises"})," burden placed on you."]}),"\n",(0,r.jsx)(t.h3,{id:"\ufe0f-example-manual-state-hook",children:"\ud83d\udee0\ufe0f Example: Manual State Hook"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'title="Counter.razor.cs"',children:"public partial class Counter : ComponentBase, IAsyncDisposable\r\n{\r\n    [Inject] IStateAccessor<CounterState> State { get; set; }\r\n    [Inject] private IDispatcher Dispatcher { get; set; }\r\n\r\n    protected override void OnInitialized()\r\n    {\r\n        State.OnStateChangedNoDetails += ShouldUpdate;\r\n    }\r\n\r\n    private void ShouldUpdate(object? sender, EventArgs e)\r\n    {\r\n        _ = InvokeAsync(StateHasChanged);\r\n    }\r\n\r\n    private async Task Increment()\r\n    {\r\n        await Dispatcher.Prepare<IncrementCounterAction>()\r\n             .With(p => p.Delay, 1)\r\n             .DispatchAsync();\r\n    }\r\n\r\n    public ValueTask DisposeAsync()\r\n    {\r\n        State.OnStateChangedNoDetails -= ShouldUpdate;\r\n        return ValueTask.CompletedTask;\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"-zero-boilerplate-state-hook",children:"\ud83c\udfaf Zero-Boilerplate State Hook"}),"\n",(0,r.jsxs)(t.p,{children:["StatePulse offers a ",(0,r.jsx)(t.strong,{children:"zero-boilerplate"})," way to subscribe to and track component-bound state changes \u2014 using ",(0,r.jsx)(t.code,{children:"IStatePulse"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["This method requires ",(0,r.jsx)(t.strong,{children:"no manual subscription or disposal"}),", yet still tracks updates ",(0,r.jsx)(t.strong,{children:"per component"}),", safely and efficiently."]}),"\n",(0,r.jsx)(t.h4,{id:"-example",children:"\ud83d\ude80 Example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'title="Counter.razor.cs"',children:"public partial class Counter : ComponentBase\r\n{\r\n    [Inject] IStatePulse Pulse { get; set; }\r\n    private CounterState State => Pulse.StateOf<CounterState>(() => this, ShouldUpdate);\r\n    [Inject] private IDispatcher Dispatcher { get; set; }\r\n    public Task ShouldUpdate() => InvokeAsync(StateHasChanged);\r\n    private async Task Increment()\r\n    {\r\n        await Dispatcher.Prepare<IncrementCounterAction>()\r\n             .With(p => p.Delay, 1)\r\n             .DispatchAsync();\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["\ud83d\udcdd ",(0,r.jsxs)(t.strong,{children:["Note on ",(0,r.jsx)(t.code,{children:"StateOf()"})," Usage"]})]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["You might notice that ",(0,r.jsx)(t.code,{children:"Pulse.StateOf<CounterState>(() => this, ShouldUpdate)"})," is called during every render.",(0,r.jsx)(t.br,{}),"\n","At first glance, this may seem inefficient \u2014 but it\u2019s actually intentional and necessary."]}),"\n",(0,r.jsxs)(t.p,{children:["This method guarantees that the component is correctly bound to the state and always get latest state.",(0,r.jsx)(t.br,{}),"\n","Without using this shorthand, you\u2019d be forced to call ",(0,r.jsx)(t.code,{children:"StateOf(...).Property"})," directly in your Razor markup, which becomes less readable and harder to maintain."]}),"\n",(0,r.jsxs)(t.p,{children:["When ",(0,r.jsx)(t.code,{children:"StateOf()"})," is called:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["StatePulse checks whether the component (identified by ",(0,r.jsx)(t.code,{children:"()=> this"}),") is already being tracked."]}),"\n",(0,r.jsxs)(t.li,{children:["If not, it sets up the binding and associates the provided ",(0,r.jsx)(t.code,{children:"ShouldUpdate"})," method as a re-render callback."]}),"\n",(0,r.jsx)(t.li,{children:"If it is already tracked, the call becomes a fast property access with near-zero overhead."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["\u26a1 ",(0,r.jsx)(t.strong,{children:"The only cost is during the initial setup."}),(0,r.jsx)(t.br,{}),"\n","All future calls are optimized and safe to run on every render."]}),"\n",(0,r.jsxs)(t.p,{children:["This design ensures you always have ",(0,r.jsx)(t.strong,{children:"up-to-date, reactive state"})," with ",(0,r.jsx)(t.strong,{children:"no boilerplate"})," and ",(0,r.jsx)(t.strong,{children:"minimal performance impact"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(6540);const r={},a=s.createContext(r);function i(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);