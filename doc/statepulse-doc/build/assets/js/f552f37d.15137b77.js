"use strict";(self.webpackChunkstatepulse_doc=self.webpackChunkstatepulse_doc||[]).push([[1653],{5679:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Create State","title":"The States","description":"Defining a State","source":"@site/docs/3.Create State.md","sourceDirName":".","slug":"/gs-state","permalink":"/gs-state","draft":false,"unlisted":false,"editUrl":"https://github.com/mshimshon/StatePulse.NET/docs/3.Create State.md","tags":[{"inline":true,"label":"blazor","permalink":"/tags/blazor"},{"inline":true,"label":"state","permalink":"/tags/state"},{"inline":true,"label":"state-management","permalink":"/tags/state-management"},{"inline":true,"label":"immutable","permalink":"/tags/immutable"},{"inline":true,"label":"csharp","permalink":"/tags/csharp"},{"inline":true,"label":".net","permalink":"/tags/net"},{"inline":true,"label":"statepulse","permalink":"/tags/statepulse"}],"version":"current","sidebarPosition":4,"frontMatter":{"slug":"gs-state","title":"The States","tags":["blazor","state","state-management","immutable","csharp",".net","statepulse"],"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"The Actions","permalink":"/gs-the-action"},"next":{"title":"The Effects","permalink":"/gs-the-effect"}}');var a=n(4848),r=n(8453);const i={slug:"gs-state",title:"The States",tags:["blazor","state","state-management","immutable","csharp",".net","statepulse"],sidebar_position:4},l=void 0,o={},c=[{value:"Defining a State",id:"defining-a-state",level:2},{value:"Example: Counter State",id:"example-counter-state",level:3},{value:"\ud83c\udfaf Manual State Hooking",id:"-manual-state-hooking",level:2},{value:"\u2705 Why This Is Optimal",id:"-why-this-is-optimal",level:3},{value:"\ud83d\udee0\ufe0f Example: Manual State Hook",id:"\ufe0f-example-manual-state-hook",level:3},{value:"\ud83c\udf00 Zero-Boilerplate Without Compromise",id:"-zero-boilerplate-without-compromise",level:2},{value:"\ud83d\udee0\ufe0f Example: Zero-Boilerplate State Hook",id:"\ufe0f-example-zero-boilerplate-state-hook",level:3}];function d(e){const t={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"defining-a-state",children:"Defining a State"}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.strong,{children:"state"})," represents a slice of your application's data. It should be:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Immutable (defined as a ",(0,a.jsx)(t.code,{children:"record"}),")"]}),"\n",(0,a.jsx)(t.li,{children:"Serializable (for debugging, testing, or persistence)"}),"\n",(0,a.jsx)(t.li,{children:"Focused (represents a single domain or feature)"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"example-counter-state",children:"Example: Counter State"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:'title="CounterState.cs"',children:"public record CounterState : IStateFeature\r\n{\r\n    public int Count { get; init; }\r\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"-manual-state-hooking",children:"\ud83c\udfaf Manual State Hooking"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"manual subscription approach"})," is the most ",(0,a.jsx)(t.strong,{children:"performant and reliable"})," way to handle state updates \u2014 in StatePulse or any other state management library."]}),"\n",(0,a.jsxs)(t.p,{children:["By ",(0,a.jsx)(t.strong,{children:"explicitly subscribing and unsubscribing"})," to a specific state, only the components that depend on that state are re-rendered.",(0,a.jsx)(t.br,{}),"\n","This avoids unnecessary rendering and offers precise control."]}),"\n",(0,a.jsx)(t.h3,{id:"-why-this-is-optimal",children:"\u2705 Why This Is Optimal"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"No overhead"})," from global tracking or base components"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Fine-grained control"})," over component updates"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Best performance"}),", especially in large apps"]}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"Works without any framework-specific magic"})}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["\u26a0\ufe0f The downside? It requires more boilerplate.",(0,a.jsx)(t.br,{}),"\n","That's why many libraries introduce alternatives like global components, wrappers, or base components \u2014 but these come with trade-offs in flexibility or overhead."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"\ufe0f-example-manual-state-hook",children:"\ud83d\udee0\ufe0f Example: Manual State Hook"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:'title="Counter.razor.cs"',children:"public partial class Counter : ComponentBase, IAsyncDisposable\r\n{\r\n    [Inject] IStateAccessor<CounterState> State { get; set; }\r\n    [Inject] private IDispatcher Dispatcher { get; set; }\r\n\r\n    protected override void OnInitialized()\r\n    {\r\n        State.OnStateChangedNoDetails += ShouldUpdate;\r\n    }\r\n\r\n    private void ShouldUpdate(object? sender, EventArgs e)\r\n    {\r\n        _ = InvokeAsync(StateHasChanged);\r\n    }\r\n\r\n    private async Task Increment()\r\n    {\r\n        await Dispatcher.Prepare<IncrementCounterAction>()\r\n             .With(p => p.Delay, 1)\r\n             .DispatchAsync();\r\n    }\r\n\r\n    public ValueTask DisposeAsync()\r\n    {\r\n        State.OnStateChangedNoDetails -= ShouldUpdate;\r\n        return ValueTask.CompletedTask;\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"-zero-boilerplate-without-compromise",children:"\ud83c\udf00 Zero-Boilerplate Without Compromise"}),"\n",(0,a.jsxs)(t.p,{children:["StatePulse ",(0,a.jsx)(t.strong,{children:"does not force you"})," to inherit from a base component or use a global component to track state changes.",(0,a.jsx)(t.br,{}),"\n","Instead, StatePulse provides a ",(0,a.jsx)(t.strong,{children:"clever and efficient mechanism"})," to track components that request state,",(0,a.jsx)(t.br,{}),"\n","binding them automatically with:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\u2705 ",(0,a.jsx)(t.strong,{children:"Memory leak protection"})]}),"\n",(0,a.jsxs)(t.li,{children:["\u26a1 ",(0,a.jsx)(t.strong,{children:"Optimized getters"})]}),"\n",(0,a.jsxs)(t.li,{children:["\ud83e\uddfc ",(0,a.jsx)(t.strong,{children:"Zero boilerplate on your side"})]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["This ensures ",(0,a.jsx)(t.strong,{children:"no architectural compromises"})," burden placed on you."]}),"\n",(0,a.jsxs)(t.p,{children:["StatePulse offers a ",(0,a.jsx)(t.strong,{children:"zero-boilerplate"})," way to subscribe to and track component-bound state changes \u2014 using ",(0,a.jsx)(t.code,{children:"IStatePulse"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["This method requires ",(0,a.jsx)(t.strong,{children:"no manual subscription or disposal"}),", yet still tracks updates ",(0,a.jsx)(t.strong,{children:"per component"}),", safely and efficiently."]}),"\n",(0,a.jsx)(t.h3,{id:"\ufe0f-example-zero-boilerplate-state-hook",children:"\ud83d\udee0\ufe0f Example: Zero-Boilerplate State Hook"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:'title="Counter.razor.cs"',children:"public partial class Counter : ComponentBase\r\n{\r\n    [Inject] IStatePulse Pulse { get; set; }\r\n    private CounterState State => Pulse.StateOf<CounterState>(() => this, ShouldUpdate);\r\n    [Inject] private IDispatcher Dispatcher { get; set; }\r\n    public Task ShouldUpdate() => InvokeAsync(StateHasChanged);\r\n    private async Task Increment()\r\n    {\r\n        await Dispatcher.Prepare<IncrementCounterAction>()\r\n             .With(p => p.Delay, 1)\r\n             .DispatchAsync();\r\n    }\r\n}\n"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["\ud83d\udcdd ",(0,a.jsxs)(t.strong,{children:["Note on ",(0,a.jsx)(t.code,{children:"StateOf()"})," Usage"]})]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["You might notice that ",(0,a.jsx)(t.code,{children:"Pulse.StateOf<CounterState>(() => this, ShouldUpdate)"})," is called during every render.",(0,a.jsx)(t.br,{}),"\n","At first glance, this may seem inefficient \u2014 but it\u2019s actually intentional and necessary."]}),"\n",(0,a.jsxs)(t.p,{children:["This method guarantees that the component is correctly bound to the state and always get latest state.",(0,a.jsx)(t.br,{}),"\n","Without using this shorthand, you\u2019d be forced to call ",(0,a.jsx)(t.code,{children:"StateOf(...).Property"})," directly in your Razor markup, which becomes less readable and harder to maintain."]}),"\n",(0,a.jsxs)(t.p,{children:["When ",(0,a.jsx)(t.code,{children:"StateOf()"})," is called:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["StatePulse checks whether the component (identified by ",(0,a.jsx)(t.code,{children:"()=> this"}),") is already being tracked."]}),"\n",(0,a.jsxs)(t.li,{children:["If not, it sets up the binding and associates the provided ",(0,a.jsx)(t.code,{children:"ShouldUpdate"})," method as a re-render callback."]}),"\n",(0,a.jsx)(t.li,{children:"If it is already tracked, the call becomes a fast property access with near-zero overhead."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["\u26a1 ",(0,a.jsx)(t.strong,{children:"The only cost is during the initial setup."}),(0,a.jsx)(t.br,{}),"\n","All future calls are optimized and safe to run on every render."]}),"\n",(0,a.jsxs)(t.p,{children:["This design ensures you always have ",(0,a.jsx)(t.strong,{children:"up-to-date, reactive state"})," with ",(0,a.jsx)(t.strong,{children:"no boilerplate"})," and ",(0,a.jsx)(t.strong,{children:"minimal performance impact"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var s=n(6540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);